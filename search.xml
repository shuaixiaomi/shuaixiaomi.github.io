<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>三个线程连续打印1～8</title>
    <url>/2024/03/24/algorithm/%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%9E%E7%BB%AD%E6%89%93%E5%8D%B01%EF%BD%9E8/</url>
    <content><![CDATA[<p>如何使用三个线程交替输出一串连续的数字</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> threadId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Printer</span><span class="params">(<span class="type">int</span> threadId, <span class="type">int</span> maxCount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadId = threadId;</span><br><span class="line">        <span class="built_in">this</span>.maxCount = maxCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count &lt;= maxCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">3</span> == threadId) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Printer</span> <span class="variable">printer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="type">Printer</span> <span class="variable">printer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="type">Printer</span> <span class="variable">printer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printer3);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>编程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2024/03/24/java-base/ThreadLocal/</url>
    <content><![CDATA[<p>ThreadLocal 内存泄漏？什么原因？怎么解决？</p>
<span id="more"></span>

<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p><img src="/2024/03/24/java-base/ThreadLocal/ThreadLocal%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB.png" alt="ThreadLocal引用关系"></p>
<h2 id="产生内存泄漏的原因"><a href="#产生内存泄漏的原因" class="headerlink" title="产生内存泄漏的原因"></a>产生内存泄漏的原因</h2><p>从上图中可以看出，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部强引用时，Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中key为null， 而value还存在着强引用，只有thead线程退出以后,value的强引用链条才会断掉。</p>
<p>但如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</p>
<blockquote>
<p>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p>
</blockquote>
<p>永远无法回收，造成内存泄漏。</p>
<h2 id="那为什么使用弱引用而不是强引用？？"><a href="#那为什么使用弱引用而不是强引用？？" class="headerlink" title="那为什么使用弱引用而不是强引用？？"></a>那为什么使用弱引用而不是强引用？？</h2><p>我们看看Key使用的</p>
<h3 id="key-使用强引用"><a href="#key-使用强引用" class="headerlink" title="key 使用强引用"></a>key 使用强引用</h3><p>回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</p>
<h3 id="key-使用弱引用"><a href="#key-使用弱引用" class="headerlink" title="key 使用弱引用"></a>key 使用弱引用</h3><p>回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调用set()、get()、remove()方法的时候会被清除value值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于Thread中包含变量ThreadLocalMap，因此ThreadLocalMap与Thread的生命周期是一样长，如果都没有手动删除对应key，都会导致内存泄漏。</p>
<p>但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set(),get(),remove()的时候会被清除。</p>
<p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p>
<h2 id="ThreadLocal正确的使用方法"><a href="#ThreadLocal正确的使用方法" class="headerlink" title="ThreadLocal正确的使用方法"></a>ThreadLocal正确的使用方法</h2><ul>
<li><p>每次使用完ThreadLocal都调用它的remove()方法清除数据。</p>
</li>
<li><p>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>基础、Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载初始化</title>
    <url>/2024/03/24/java-base/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Java类加载初始化过程"><a href="#Java类加载初始化过程" class="headerlink" title="Java类加载初始化过程"></a>Java类加载初始化过程</h1><span id="more"></span>

<ul>
<li><p>加载（Loading）<br>当程序中使用到某个类时，JVM会检查该类是否已经加载到内存中。如果没有加载，则通过类加载器（ClassLoader）将类的字节码文件加载到内存中。</p>
</li>
<li><p>连接（Linking）  </p>
<ul>
<li>验证（Verification）<br>  确保加载的类符合Java语言规范，不会造成安全漏洞。</li>
<li>准备（Preparation）<br>  为类的静态变量分配内存空间，并设置默认初始值（零值），如int类型为0，对象引用类型为null。</li>
<li>解析（Resolution）<br>  将类、方法、字段等符号引用解析为直接引用，这一步可能包括将符号引用转换为直接指针等操作。<br>  符号引用：即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。<br>  直接引用：可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量。</li>
</ul>
</li>
<li><p>初始化（Initialization）<br>这是类初始化的最后一步，也是最重要的一步。在初始化阶段，JVM会按照以下顺序执行以下操作：</p>
<ul>
<li>执行静态变量的赋值操作，即静态初始化块（static initializer blocks）和静态变量的赋值语句。</li>
<li>执行静态初始化块中的代码，这些代码通常用于静态资源的初始化，如静态成员变量或静态方法中的逻辑。</li>
<li>如果类有父类，会先执行父类的初始化操作。</li>
<li>如果有必要的话，会初始化类中的实例变量，但这只有在实例被创建时才会发生。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>基础、Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql 问题集</title>
    <url>/2024/03/24/mysql/interview/</url>
    <content><![CDATA[<h1 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h1><p>索引是一种可以提高数据库查询效率的数据结构。</p>
<span id="more"></span>

<h1 id="索引有那些类型？"><a href="#索引有那些类型？" class="headerlink" title="索引有那些类型？"></a>索引有那些类型？</h1><h1 id="那些场景下索引会失效？"><a href="#那些场景下索引会失效？" class="headerlink" title="那些场景下索引会失效？"></a>那些场景下索引会失效？</h1><ol>
<li>like以%开头</li>
<li>不符合联合索引最左前缀原则</li>
<li>联表查询，表的编码不一致</li>
<li>需要类型转换</li>
<li>查询条件有数学运算</li>
<li>查询条件使用了函数</li>
<li>mysql觉得走索引更慢，比如数据较少时</li>
</ol>
<h1 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h1><p>事务是访问和更新数据库的程序执行单元；事务中可能包含一个或多个sql语句，这些语句要么都执行，要么都不执行。事务的四个特性(<a href="../transaction/#ACID">ACID</a>)：原子性（Atomicity），一致性（Consistency），隔离性（Isolation），持久性（Durability）。<br>MySQL原生的MyISAM [maiˈzæm] 引擎就不支持事务。</p>
<h1 id="为什么建议尽量不要使用长事务？"><a href="#为什么建议尽量不要使用长事务？" class="headerlink" title="为什么建议尽量不要使用长事务？"></a>为什么建议尽量不要使用长事务？</h1><ol>
<li>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。</li>
<li>长事务会长时间占据锁资源，容易造成死锁和锁超时。</li>
</ol>
<h1 id="可重复读隔离级别下，还会出现幻读吗？"><a href="#可重复读隔离级别下，还会出现幻读吗？" class="headerlink" title="可重复读隔离级别下，还会出现幻读吗？"></a>可重复读隔离级别下，还会出现幻读吗？</h1><p><a href="../transaction/#%E9%82%A3%E4%B9%88%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8C%E8%BF%98%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%B9%BB%E8%AF%BB%E5%90%97%EF%BC%9F">会</a></p>
]]></content>
      <tags>
        <tag>MySql</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql 事务篇</title>
    <url>/2024/03/24/mysql/transaction/</url>
    <content><![CDATA[<h1 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h1><p>事务是访问和更新数据库的程序执行单元；事务中可能包含一个或多个sql语句，这些语句要么都执行，要么都不执行。 事务的四个特性(ACID)：原子性（Atomicity），一致性（Consistency），隔离性（Isolation），持久性（Durability）。<br>MySQL原生的MyISAM [maiˈzæm] 引擎就不支持事务。</p>
<span id="more"></span>

<h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><ul>
<li>定义：指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。  </li>
<li>实现：InnoDB通过undo log日志来实现原子性，当事务对数据库进行修改时，InnoDB会生成对应的undo log日志，记录sql执行的相关信息，如果事务执行失败或调用了rollback，导致事务需要回滚，就可以通过undo log 日志进行回滚，例如执行了一条插入语句，回滚时就执行删除。</li>
</ul>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><ul>
<li>定义：指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。</li>
<li>实现：可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。<br>实现一致性的措施包括：<ul>
<li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证。</li>
<li>数据库本身提供保障，例如不允许向整形列插入字符串值。</li>
<li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致。</li>
</ul>
</li>
</ul>
<h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><ul>
<li>定义：指事务一旦提交，它对数据库的改变就应该是永久性的。</li>
<li>实现：InnoDB通过redo log日志来实现持久性，当数据被修改时，InnoDB会在redo log中记录这次操作，等到事务提交时，会将redo log上的记录刷新到磁盘上。</li>
</ul>
<h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><ul>
<li>定义：指事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>实现：隔离性通过两个方面来实现：<ul>
<li>(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性<br>  锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</li>
<li>(一个事务)写操作对(另一个事务)读操作的影响：MVCC(多版本并发控制)保证隔离性<br>  相较于锁机制，MVCC最大的优点在于读不加锁，并发性能好。</li>
</ul>
</li>
</ul>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><ul>
<li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。</li>
<li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)。</li>
<li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读。</li>
<li>串行化(Serializable)：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<h1 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h1><h2 id="MVCC是什么？"><a href="#MVCC是什么？" class="headerlink" title="MVCC是什么？"></a>MVCC是什么？</h2><p>MVCC就是保存数据的历史版本，通过对数据行的多版本管理来实现数据库的并发控制。</p>
<h2 id="MVCC是如何工作的？"><a href="#MVCC是如何工作的？" class="headerlink" title="MVCC是如何工作的？"></a>MVCC是如何工作的？</h2><p>以InnoDB为例，在事务开启时，会申请一个事务ID，这个事务ID是按申请顺序严格递增的。每次事务更改数据时，都会生成一个新的数据版本，并把这个事务ID和这个数据版本关联。当事务去查询数据(快照读)时，会根据事务ID查询对应的数据版本以及当前事务ID可见的数据版本，也就是快照。</p>
<ul>
<li>当前读：<ol>
<li>update … (更新操作)</li>
<li>delete … (删除操作)</li>
<li>insert … (插入操作)</li>
<li>select … lock in share mode (共享读锁)</li>
<li>select … for update (写锁)</li>
</ol>
</li>
<li>快照读：<ol>
<li>单纯的select操作 （不包括上面当前读的select … lock in share mode,select … for update)</li>
<li>Read Committed隔离级别：每次select都生成一个快照读</li>
<li>Read Repeatable隔离级别：开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读，如下图示例1。</li>
</ol>
</li>
</ul>
<p>示例1：<br><img src="/2024/03/24/mysql/transaction/%E5%BF%AB%E7%85%A7%E8%AF%BB.png" alt="快照读"><br>可以看到，虽然事务2比事务1先开启，但是事务1能读到事务2修改的数据，这就是因为虽然事务1比事务2先开启，但是事务1还没有执行select语句，还没生成快照。</p>
<p>示例2：<br><img src="/2024/03/24/mysql/transaction/%E5%BF%AB%E7%85%A7%E8%AF%BB2.png" alt="快照读2"><br>由上图可以看出，虽然事务1先执行了update语句，但后面还是能查到事务2修改的数据，说明此时事务1并未生成快照。</p>
<p>示例3：<br><img src="/2024/03/24/mysql/transaction/%E5%BF%AB%E7%85%A7%E8%AF%BB3.png" alt="快照读3"><br>生成快照后，快照读出来的数据就是生成快照时的数据，无论其他事务后续如何更改，都不会影响到当前事务。</p>
<h2 id="那么可重复读隔离级别下，还会出现幻读吗？"><a href="#那么可重复读隔离级别下，还会出现幻读吗？" class="headerlink" title="那么可重复读隔离级别下，还会出现幻读吗？"></a>那么可重复读隔离级别下，还会出现幻读吗？</h2><p>回答这个问题之前，先说下什么是幻读。<br>幻读最早由 ANSI SQL-92 的隔离级别定义中提出：</p>
<blockquote>
<p>P3 (Phantom): Transaction T1 reads a set of data items satisfying some . Transaction T2 then creates data items that satisfy T1’s and commits. If T1 then repeats its read with the same , it gets a set of data items different from the first read.</p>
</blockquote>
<p>翻译一下：<br>事务 T1 读取一组满足某些 &lt;搜索条件&gt; 的数据。事务 T2 创建了满足 T1 的 &lt;搜索条件&gt; 的数据项并提交。如果 T1 用相同的&lt;搜索条件&gt;再次读取，得到一组不同于第一次读取的数据。这就叫幻读。</p>
<p><img src="/2024/03/24/mysql/transaction/%E5%B9%BB%E8%AF%BB%E7%A4%BA%E4%BE%8B1.png" alt="幻读示例1"><br>可以看到在右边的事务执行insert后，左边的事务并不能查到新插入的数据，但是在执行了update语句后，就能查到，所以说，即使是可重复读隔离级别下还是会出现幻读。</p>
]]></content>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Redisson来实现一个分布式锁</title>
    <url>/2024/03/24/redis/redisson/</url>
    <content><![CDATA[<h1 id="提问，如果让你来实现一个分布式锁，打算怎么实现？"><a href="#提问，如果让你来实现一个分布式锁，打算怎么实现？" class="headerlink" title="提问，如果让你来实现一个分布式锁，打算怎么实现？"></a>提问，如果让你来实现一个分布式锁，打算怎么实现？</h1><span id="more"></span>

<p>以 Redisson 为例，来说说分布式锁的一种实现方式。</p>
<h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><p>默认非公平锁，<a href="../redisson_fair_lock#%E5%85%AC%E5%B9%B3%E9%94%81lua%E8%84%9A%E6%9C%AC">公平锁另见</a>，Redisson 通过使用lua脚本，来保证加锁操作的原子性()。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">KEYS[1]：锁的名字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ARGV[1]：锁持续时间</span></span><br><span class="line"><span class="comment">ARGV[2]：UUID:ThreadId 组合 a3da2c83-b084-425c-a70f-5d9a08b37f31:1</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 判断锁是否存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">then</span> </span><br><span class="line">  <span class="comment">-- Hincrby 命令用于为哈希表中的字段值加上指定增量值</span></span><br><span class="line">  redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>); </span><br><span class="line">  <span class="comment">-- PEXPIRE 命令 以毫秒为单位设置 key 的生存时间 EXPIRE 以秒为单位</span></span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当前线程是否持有锁 ARGV[2]: threadId</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span>  </span><br><span class="line">  redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Pttl 命令以毫秒为单位返回 key 的剩余过期时间。</span></span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]); </span><br></pre></td></tr></table></figure>
<p>可以看到Redisson通过Redis一个value是Hash结构的键值对来当作锁，key 就是锁的名字，hash的field是客户端线程id，value是客户端获取的次数，这样就实现了可重入锁。<br>获取锁成功，则返回null，如果获取失败，则返回锁剩余过期时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">boolean</span> interruptibly)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">//         lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);</span><br><span class="line">        pubSub.timeout(future);</span><br><span class="line">        RedissonLockEntry entry;</span><br><span class="line">        <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">            entry = commandExecutor.getInterrupted(future);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry = commandExecutor.get(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                ttl = tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line">                <span class="comment">// lock acquired</span></span><br><span class="line">                <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// waiting for message</span></span><br><span class="line">                <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        entry.getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        entry.getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                        entry.getLatch().acquire();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        entry.getLatch().acquireUninterruptibly();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unsubscribe(entry, threadId);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        get(lockAsync(leaseTime, unit));</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果获取失败，客户端则会自旋获取锁，直到成功获取锁。</p>
<h2 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h2><p>解锁lua脚本</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">KEYS[1]：锁的名字</span></span><br><span class="line"><span class="comment">KEYS[2]: 订阅频道</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ARGV[1]：UNLOCK_MESSAGE</span></span><br><span class="line"><span class="comment">ARGV[2]：锁持续时间 </span></span><br><span class="line"><span class="comment">ARGV[3]：UUID:ThreadId 组合 a3da2c83-b084-425c-a70f-5d9a08b37f31:1</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 线程没持有锁，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>]) == <span class="number">0</span>) <span class="keyword">then</span>  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>; </span><br><span class="line"><span class="keyword">end</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 减少一次重入，如果还有持有次数，重新设置存活事件</span></span><br><span class="line"><span class="keyword">local</span> counter = redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>], <span class="number">-1</span>);  </span><br><span class="line"><span class="keyword">if</span> (counter &gt; <span class="number">0</span>) <span class="keyword">then</span>  </span><br><span class="line">   redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]);  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">   <span class="comment">-- 没有持有次数，删除key，推送解锁消息</span></span><br><span class="line">   redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]);  </span><br><span class="line">   redis.call(<span class="string">&#x27;publish&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>]);  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line"><span class="keyword">end</span>;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br></pre></td></tr></table></figure>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="如果因为过期时间到了锁释放导致其他线程获取到锁，但是持有锁的线程还没有处理完任务，该怎么办？"><a href="#如果因为过期时间到了锁释放导致其他线程获取到锁，但是持有锁的线程还没有处理完任务，该怎么办？" class="headerlink" title="如果因为过期时间到了锁释放导致其他线程获取到锁，但是持有锁的线程还没有处理完任务，该怎么办？"></a>如果因为过期时间到了锁释放导致其他线程获取到锁，但是持有锁的线程还没有处理完任务，该怎么办？</h2><p>Redisson有一个“看门狗”机制——基于时间轮，针对每一个线程启动一个定时任务去自动延长锁的有效期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleExpirationRenewal</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpirationEntry</span>();</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">oldEntry</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);</span><br><span class="line">    <span class="keyword">if</span> (oldEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldEntry.addThreadId(threadId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        entry.addThreadId(threadId);</span><br><span class="line">        renewExpiration();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, Integer&gt; threadIds = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Timeout timeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ExpirationEntry</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addThreadId</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">counter</span> <span class="operator">=</span> threadIds.get(threadId);</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="literal">null</span>) &#123;</span><br><span class="line">        counter = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    threadIds.put(threadId, counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时任务只会在第一次获取到锁时才会开启，后续获取到锁之后只会记录次数。</p>
<p>定时任务同样是通过lua脚本来延长有效期</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span>  </span><br><span class="line">   redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">end</span>;  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这里要注意一点就是，如果调用lock()方法时，指定了过期时间，那么是不会触发看门狗的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>leaseTime !&#x3D; -1 时直接返回。</p>
<h2 id="看门狗触发后会一直执行吗？"><a href="#看门狗触发后会一直执行吗？" class="headerlink" title="看门狗触发后会一直执行吗？"></a>看门狗触发后会一直执行吗？</h2><p>不会，unlock()方法中会去取消定时任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title function_">unlockAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    RPromise&lt;Void&gt; result = <span class="keyword">new</span> <span class="title class_">RedissonPromise</span>&lt;Void&gt;();</span><br><span class="line">    RFuture&lt;Boolean&gt; future = unlockInnerAsync(threadId);</span><br><span class="line"></span><br><span class="line">    future.onComplete((opStatus, e) -&gt; &#123;</span><br><span class="line">        <span class="comment">//取消到期续订</span></span><br><span class="line">        cancelExpirationRenewal(threadId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            result.tryFailure(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opStatus == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">IllegalMonitorStateException</span> <span class="variable">cause</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(<span class="string">&quot;attempt to unlock lock, not locked by current thread by node id: &quot;</span></span><br><span class="line">                    + id + <span class="string">&quot; thread-id: &quot;</span> + threadId);</span><br><span class="line">            result.tryFailure(cause);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.trySuccess(<span class="literal">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">cancelExpirationRenewal</span><span class="params">(Long threadId)</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">task</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (threadId != <span class="literal">null</span>) &#123;</span><br><span class="line">        task.removeThreadId(threadId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (threadId == <span class="literal">null</span> || task.hasNoThreads()) &#123;</span><br><span class="line">        <span class="type">Timeout</span> <span class="variable">timeout</span> <span class="operator">=</span> task.getTimeout();</span><br><span class="line">        <span class="keyword">if</span> (timeout != <span class="literal">null</span>) &#123;</span><br><span class="line">            timeout.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        EXPIRATION_RENEWAL_MAP.remove(getEntryName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNoThreads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> threadIds.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但其实这里有一个Redisson解决不了的问题（不知道算不算问题），那就是如果获取锁的线程因一些原因导致中断了而无法调用unlock()方法，那么看门狗会一直执行下去，所以要注意保证代码能执行unlock()。<a href="https://github.com/redisson/redisson/issues/2714">Redisson Issues</a></p>
]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>Redisson</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Redisson 公平锁</title>
    <url>/2024/03/24/redis/redisson_fair_lock/</url>
    <content><![CDATA[<h1 id="公平锁lua脚本"><a href="#公平锁lua脚本" class="headerlink" title="公平锁lua脚本"></a>公平锁lua脚本</h1><span id="more"></span>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">KEYS[1]：锁的名字; </span></span><br><span class="line"><span class="comment">KEYS[2]：加锁等待队列，redisson_lock_queue:&#123;lockName&#125;;</span></span><br><span class="line"><span class="comment">KEYS[3]：等待队列中线程锁时间的 set 集合，redisson_lock_timeout:&#123;lockName&#125;，是按照锁的时间戳存放到集合中的;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ARGV[1]：锁超时时间 30000</span></span><br><span class="line"><span class="comment">ARGV[2]：UUID:ThreadId 组合 a3da2c83-b084-425c-a70f-5d9a08b37f31:1</span></span><br><span class="line"><span class="comment">ARGV[3]：threadWaitTime 默认 300000</span></span><br><span class="line"><span class="comment">ARGV[4]：currentTime 当前时间戳</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 移除过时无用的线程</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span>  </span><br><span class="line">  <span class="comment">-- 获取等待队列的第一个元素,就是第一个等待线程</span></span><br><span class="line">  <span class="keyword">local</span> firstThreadId2 = redis.call(<span class="string">&#x27;lindex&#x27;</span>, KEYS[<span class="number">2</span>], <span class="number">0</span>); </span><br><span class="line">  <span class="comment">-- 如果没有线程，直接结束循环</span></span><br><span class="line">  <span class="keyword">if</span> firstThreadId2 == <span class="literal">false</span> <span class="keyword">then</span>  </span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line">  <span class="keyword">end</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 获取等待线程的分数，也就是等待线程获取锁时的时间戳</span></span><br><span class="line">  <span class="keyword">local</span> timeout = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;zscore&#x27;</span>, KEYS[<span class="number">3</span>], firstThreadId2)); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 如果时间戳小于当前时间，就从超时队列和等待队列中移除</span></span><br><span class="line">  <span class="keyword">if</span> timeout &lt;= <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>]) <span class="keyword">then</span>  </span><br><span class="line">    redis.call(<span class="string">&#x27;zrem&#x27;</span>, KEYS[<span class="number">3</span>], firstThreadId2); </span><br><span class="line">    redis.call(<span class="string">&#x27;lpop&#x27;</span>, KEYS[<span class="number">2</span>]); </span><br><span class="line">  <span class="keyword">else</span>  </span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line">  <span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再次尝试获取锁</span></span><br><span class="line"><span class="comment">-- 能获取到锁 and （ 锁存在 or 当前线程在等待队列第一个 ）</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>)  </span><br><span class="line">  <span class="keyword">and</span> ((redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">2</span>]) == <span class="number">0</span>)  </span><br><span class="line">  <span class="keyword">or</span> (redis.call(<span class="string">&#x27;lindex&#x27;</span>, KEYS[<span class="number">2</span>], <span class="number">0</span>) == ARGV[<span class="number">2</span>])) <span class="keyword">then</span>  </span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 从等待队列和超时队列中移除当前线程</span></span><br><span class="line">  redis.call(<span class="string">&#x27;lpop&#x27;</span>, KEYS[<span class="number">2</span>]); </span><br><span class="line">  redis.call(<span class="string">&#x27;zrem&#x27;</span>, KEYS[<span class="number">3</span>], ARGV[<span class="number">2</span>]); </span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 减少所有等待线程的超时时间，zrange：按照分数从小到大返回指定区间的成员 </span></span><br><span class="line">  <span class="keyword">local</span> keys = redis.call(<span class="string">&#x27;zrange&#x27;</span>, KEYS[<span class="number">3</span>], <span class="number">0</span>, <span class="number">-1</span>); </span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">1</span>, #keys, <span class="number">1</span> <span class="keyword">do</span>  </span><br><span class="line">    <span class="comment">-- ZINCRBY key increment member</span></span><br><span class="line">    <span class="comment">-- Zincrby 命令对有序集合中指定成员的分数加上增量 increment， 可以通过传递一个负数值 increment ，让分数减去相应的值</span></span><br><span class="line">    redis.call(<span class="string">&#x27;zincrby&#x27;</span>, KEYS[<span class="number">3</span>], -<span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>]), keys[i]); </span><br><span class="line">  <span class="keyword">end</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 设置锁和锁的超时时间</span></span><br><span class="line">  redis.call(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>); </span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>; </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当前线程已经持有锁，锁重入</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span> <span class="keyword">then</span>  </span><br><span class="line">  redis.call(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>],<span class="number">1</span>); </span><br><span class="line">  redis.call(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>; </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取锁失败</span></span><br><span class="line"><span class="comment">-- 检查当前线程是否在等待队列</span></span><br><span class="line"><span class="keyword">local</span> timeout = redis.call(<span class="string">&#x27;zscore&#x27;</span>, KEYS[<span class="number">3</span>], ARGV[<span class="number">2</span>]); </span><br><span class="line"><span class="comment">-- ~= 不等于，这里 timeout ~= false 说明在等待队列中</span></span><br><span class="line"><span class="keyword">if</span> timeout ~= <span class="literal">false</span> <span class="keyword">then</span>  </span><br><span class="line">  <span class="comment">-- 实际超时是队列中前一个线程的超时，但这大致正确，并且避免了遍历队列</span></span><br><span class="line">  <span class="keyword">return</span> timeout - <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>]) - <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>]); </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不在队列中</span></span><br><span class="line"><span class="comment">-- 将线程添加到队列末尾，并在超时设置中将其超时设置为队列中前一个线程的超时</span></span><br><span class="line"><span class="comment">-- 获取等待队列最后一个线程</span></span><br><span class="line"><span class="keyword">local</span> lastThreadId = redis.call(<span class="string">&#x27;lindex&#x27;</span>, KEYS[<span class="number">2</span>], <span class="number">-1</span>); </span><br><span class="line"><span class="keyword">local</span> ttl; </span><br><span class="line"><span class="comment">-- 最后一个等待线程不是自己</span></span><br><span class="line"><span class="keyword">if</span> lastThreadId ~= <span class="literal">false</span> <span class="keyword">and</span> lastThreadId ~= ARGV[<span class="number">2</span>] <span class="keyword">then</span>  </span><br><span class="line">  <span class="comment">-- 等待线程的分数-当前时间戳</span></span><br><span class="line">  ttl = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;zscore&#x27;</span>, KEYS[<span class="number">3</span>], lastThreadId)) - <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>]); </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">  <span class="comment">-- 当前锁的剩余时间</span></span><br><span class="line">  ttl = redis.call(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]); </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置超时时间 等待时间+当前时间戳</span></span><br><span class="line"><span class="keyword">local</span> timeout = ttl + <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>]) + <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>]); </span><br><span class="line"><span class="comment">-- 添加到超时队列和等待队列</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;zadd&#x27;</span>, KEYS[<span class="number">3</span>], timeout, ARGV[<span class="number">2</span>]) == <span class="number">1</span> <span class="keyword">then</span>  </span><br><span class="line">  redis.call(<span class="string">&#x27;rpush&#x27;</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">2</span>]); </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">return</span> ttl;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>Redisson</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
</search>
